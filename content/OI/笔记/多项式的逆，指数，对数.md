---
tags:
  - 多项式/多项式求逆
  - 快速数论变换_NTT
  - undone
  - 多项式/多项式求对数
  - 多项式/多项式求指数
---
## 问题 1：逆

[P4238 【模板】多项式乘法逆 - 洛谷](https://www.luogu.com.cn/problem/P4238)
已知一个多项式 A， 求其逆多项式 $B=\frac 1 A \ \text{mod} \ x^n$ 的结果
## 基本思想
首先转化成求前 $2^k$ 次项，有
$$
A\times B\equiv 1\pmod{x^{2^k}}
$$
接着假设已经求出了 $2^{k-1}$ 次的结果为 B‘ ，有
$$
A\times B'\equiv 1\pmod{x^{2^{k-1}}}
$$
那么有
$$
\begin{align}
A\times B'-A\times B&\equiv 0\pmod{x^{2^{k-1}}}\\
B'-B&\equiv 0\pmod{x^{2^{k-1}}}
\end{align}
$$
平方，有
$$
\begin{align}
(B'-B)^2&\equiv 0\pmod{x^{2^k}} \\
B^2+B'^2-2BB'&\equiv 0\pmod{x^{2^k}} \\
B^2&\equiv -B'^2+2BB'\pmod{x^{2^k}} \\
\end{align}
$$
**两边同乘 A 有**
$$
\begin{align}
(B'-B)^2&\equiv 0\pmod{x^{2^k}} \\
B^2+B'^2-2BB'&\equiv 0\pmod{x^{2^k}} \\
B&\equiv -AB'^2+2B'\pmod{x^{2^k}} \\
\end{align}
$$
然后倍增就做完了，复杂度 $O(n\log n)$

>[!为什么不直接转点值求逆后再转回系数]
>在求 FFT 时，所求得的系数实际上是 F \* G 的模 $2^k$ 循环卷积，所以直接做的话就会把后面的所有项也都加到前面，这并不是这题要求的，但是在模 $2^k$ 意义下是对的.
>[相关讨论](https://www.luogu.com.cn/discuss/1128260)

>[!IDEA]
>这里多项式的逆元也是存在的，而且看起来是和数字的运算方式是一样的，发现多项式扩展成形式幂级数之后就变成了一个数环，但还不是数域，因为x就没有逆元。
>[[多项式与数域 数环]]

## 代码实现
```cpp
// 1/F(x) mod x^len
Poly<int> inverse(Poly<int> F, int len) {
    Poly<int> G(0); G[0] = qpow(F[0],mod-2);
    for(int i=1;i<len;i<<=1)G=(2*G-G*G*F).resize(i);
    return (2*G-G*G*F).resize(len-1);
}

signed main() {
    Poly<int>::init(); // init important
    File(test);
    int n;cin>>n;
    Poly F(n-1);
    cin>>F;
    cout<<inverse(F,n);
    return 0;
}
```

参考：
[P4238 【模板】多项式乘法逆 - 洛谷](https://www.luogu.com.cn/problem/P4238)

## 问题 2：求导，积分

trivial
求导就是 $f'_i=(i+1)f_{i+1}$，
积分就是 $f'_i=\frac{f_{i-1}}i$，$f'_0=C$ 这里的 C 要视情况决定，代码里设为 0
这里对大量数的逆元运用经典的 trick
## 代码实现
```cpp
Poly D() {
	Poly& F=*this;
	if (F.deg==0)return Poly(0);
	Poly G(F.deg-1);
	For(i,0,G.deg) G[i]=(ll)(i+1)*F[i+1]%mod;
	return G;
}

// 逆元在 init 里处理好了
Poly I() {
	Poly& F=*this;
	Poly G(F.deg+1);G[0]=0;
	For(i,1,G.deg) G[i]=(ll)F[i-1]*inv[i]%mod;
	return G;
}
```

## 问题 3：对数

[P4725 【模板】多项式对数函数（多项式 ln） - 洛谷](https://www.luogu.com.cn/problem/P4725)
给出 $n-1$ 次多项式 $A(x)$，求一个 $\bmod{\:x^n}$ 下的多项式 $B(x)$，满足 $B(x) \equiv \ln A(x)$。其中 $a_0=1$. 系数对 $998244353$ 取模。
## 思想

给等式两侧求导，得到
$$
B'(x) \equiv A'(x)\frac 1 {A(x)}
$$
于是 
$$
B(x)=\int A'(x)\frac 1{A(x)}
$$
其中积分，求导，求逆都在前面叙述过了, C 的话 x = 0 时，得到 $b_0=\ln a_0=0$ 

>[!如果a0 != 1]
>这样的函数是没有模意义下的 ln 的
>[解释](https://www.luogu.com.cn/article/cua49hig)
## 代码实现
```cpp
// ln F(x) mod x^len
Poly Ln(Poly F, int len) {
    if (len == 1) return Poly(0);
    return (F.D()*inverse(F,len)).resize(len-2).I();
}
```

## 问题 3：指数

[P4726 【模板】多项式指数函数（多项式 exp） - 洛谷](https://www.luogu.com.cn/problem/P4726)
给出 $n-1$ 次多项式 $A(x)$，求一个 $\bmod{\:x^n}$ 下的多项式 $B(x)$，满足 $B(x) \equiv \text e^{A(x)}$。其中 $a_0=0$. 系数对 $998244353$ 取模。

## 思想

求导得
$$
\begin{align}
B'(x)&\equiv A'(x) e^{A(x)}\\
B'(x)&\equiv A'(x) B(x)\\
\end{align}
$$
再积分得
$$
\begin{align}
B(x)&\equiv\int B(x)A'(x) \\
\end{align}
$$

## 代码实现
```cpp

```

参考：
[多项式牛顿迭代+多项式exp - 洛谷专栏](https://www.luogu.com.cn/article/tmx1wf3f)
[半在线卷积 - 洛谷专栏](https://www.luogu.com.cn/article/fwqkoyjx)
[多项式牛顿迭代](https://www.luogu.com.cn/article/02kg81xg)
