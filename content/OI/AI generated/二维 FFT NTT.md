你说得对，让我详细解释为什么二维 FFT/NTT 能正确计算二维多项式卷积。这涉及一些核心的数学原理。

## 1. 基础理论：二维卷积的可分离性

对于二元多项式卷积：
$$
C(x, y) = A(x, y) \cdot B(x, y)
$$
其中：
$$
A(x, y) = \sum_{i=0}^{M_x-1}\sum_{j=0}^{M_y-1} a_{ij} x^i y^j
$$
$$
B(x, y) = \sum_{p=0}^{N_x-1}\sum_{q=0}^{N_y-1} b_{pq} x^p y^q
$$
$$
C(x, y) = \sum_{k=0}^{M_x+N_x-2}\sum_{l=0}^{M_y+N_y-2} c_{kl} x^k y^l
$$

**卷积核心理念**：
$$
c_{kl} = \sum_{i+p=k}\sum_{j+q=l} a_{ij} \cdot b_{pq}
$$
这是一个标准的**二维线性卷积**。

## 2. 为什么二维 FFT 能计算这个卷积？

### 2.1 一维情况的回顾
对于一维卷积 $c_k = \sum_{i+j=k} a_i b_j$：
- **时域卷积 = 频域乘积**：$\mathcal{F}\{a * b\} = \mathcal{F}\{a\} \cdot \mathcal{F}\{b\}$
- 通过 FFT 将 $O(n^2)$ 的卷积降低到 $O(n \log n)$

### 2.2 推广到二维
二维 DFT 定义为：
$$
\hat{A}_{uv} = \sum_{i=0}^{M-1}\sum_{j=0}^{N-1} a_{ij} \cdot e^{-2\pi i (iu/M + jv/N)}
$$

**关键性质**：二维 DFT 是**可分离的**（separable）：
$$
\hat{A}_{uv} = \sum_{i=0}^{M-1} \left( \sum_{j=0}^{N-1} a_{ij} e^{-2\pi i jv/N} \right) e^{-2\pi i iu/M}
$$
这意味着可以先对每一行做一维 DFT，然后对每一列做一维 DFT。

## 3. 证明：二维卷积定理

**定理**：如果 $c = a * b$（二维卷积），那么：
$$
\mathcal{F}_{2D}\{c\} = \mathcal{F}_{2D}\{a\} \cdot \mathcal{F}_{2D}\{b\}
$$
其中 $\cdot$ 是逐元素相乘。

**证明思路**：
1. 将二维卷积写成双重求和形式：
   $$
   c_{kl} = \sum_{i}\sum_{j} a_{ij} b_{k-i, l-j}
   $$
2. 应用二维 DFT：
   $$
   \hat{c}_{uv} = \sum_{k}\sum_{l} c_{kl} e^{-2\pi i (ku/M + lv/N)}
   $$
3. 代入卷积定义，交换求和顺序
4. 进行变量替换，分离出两个独立的 DFT
5. 得到乘积形式

## 4. 算法正确性验证

### 4.1 实现步骤的等价性

我的代码实现：
```cpp
// 1. 对每一行进行一维NTT
for (int i = 0; i < rows; i++) {
    ntt(data[i], invert);
}

// 2. 转置矩阵
vector<vector<int>> transposed(cols, vector<int>(rows));

// 3. 对转置后的每一行（原矩阵的每一列）进行NTT
for (int j = 0; j < cols; j++) {
    ntt(transposed[j], invert);
}

// 4. 转置回来
```

**为什么这是正确的二维 NTT？**
- 步骤1：对每行做 NTT，相当于对 y 维度做变换
- 步骤2-4：对每列做 NTT，相当于对 x 维度做变换
- 整体效果 = 先对 y 后对 x 做一维 NTT = 二维 NTT

### 4.2 数学形式化验证

设 $A$ 为 $M \times N$ 矩阵，表示多项式系数。

**算法过程**：
1. 对每行做 DFT：$A'_{i,v} = \sum_{j=0}^{N-1} A_{i,j} \cdot \omega_N^{jv}$
2. 转置：$(A')^T$
3. 对每行做 DFT：$\hat{A}_{u,v} = \sum_{i=0}^{M-1} (A')^T_{v,i} \cdot \omega_M^{iu}$
   $$
   = \sum_{i=0}^{M-1} \left( \sum_{j=0}^{N-1} A_{i,j} \omega_N^{jv} \right) \omega_M^{iu}
   $$
   $$
   = \sum_{i=0}^{M-1}\sum_{j=0}^{N-1} A_{i,j} \omega_M^{iu} \omega_N^{jv}
   $$
这正是二维 DFT 的定义式。

## 5. 边界处理与循环卷积问题

### 5.1 线性卷积 vs 循环卷积
二维 DFT 计算的是**循环卷积**（circular convolution）：
$$
c_{kl} = \sum_{i}\sum_{j} a_{ij} b_{(k-i)\bmod M, (l-j)\bmod N}
$$

对于多项式乘法，我们需要**线性卷积**。

### 5.2 解决方案：零填充
将矩阵大小扩充到：
- 新行数 ≥ $M_x + N_x - 1$
- 新列数 ≥ $M_y + N_y - 1$

我的代码实现：
```cpp
int new_rows = 1;
while (new_rows < rows + other.rows - 1) new_rows <<= 1;
int new_cols = 1;
while (new_cols < cols + other.cols - 1) new_cols <<= 1;
```

这样确保循环卷积 = 线性卷积（没有环绕效应）。

## 6. 实例验证

考虑简单例子：
$$
A(x,y) = 1 + 2x + 3y
$$
$$
B(x,y) = 1 + x + y
$$

### 6.1 手工计算：
$$
C = (1 + 2x + 3y)(1 + x + y)
$$
$$
= 1 + x + y + 2x + 2x^2 + 2xy + 3y + 3xy + 3y^2
$$
$$
= 1 + 3x + 4y + 2x^2 + 5xy + 3y^2
$$

系数矩阵：
```
A = [[1, 3],   // 常数项1，y系数3
     [2, 0]]   // x系数2，xy系数0
     
B = [[1, 1],   // 常数项1，y系数1
     [1, 0]]   // x系数1，xy系数0
```

### 6.2 二维卷积验证：
$$
c_{00} = 1×1 = 1
$$
$$
c_{10} = 2×1 + 1×1 = 3
$$
$$
c_{01} = 3×1 + 1×1 = 4
$$
$$
c_{20} = 2×1 = 2
$$
$$
c_{11} = 2×1 + 3×1 = 5
$$
$$
c_{02} = 3×1 = 3
$$

与手工计算一致。

## 7. 复杂度正确性

### 7.1 朴素算法复杂度：
- 直接计算：$O(M_x N_x M_y N_y)$

### 7.2 二维 FFT/NTT 复杂度：
1. 每行 FFT：$M$ 行 × $O(N \log N)$ = $O(MN \log N)$
2. 每列 FFT：$N$ 列 × $O(M \log M)$ = $O(MN \log M)$
3. 总复杂度：$O(MN (\log M + \log N)) = O(MN \log(MN))$

## 8. 模数限制（NTT 特有问题）

对于 NTT（数论变换）：
- 模数 $p$ 必须是质数
- 存在原根 $g$ 使得 $g^{(p-1)/n}$ 是 $n$ 次单位根
- 对于 $MOD = 998244353$，$g = 3$ 是原根
- 变换长度必须是 $2^k$ 且 $2^k \mid (p-1)$，这里 $p-1 = 998244352 = 2^{23} × 7 × 17$

## 总结

二维 FFT/NTT 计算多项式卷积的正确性基于：
1. **卷积定理**：时域卷积 = 频域乘积
2. **可分离性**：二维变换可以分解为两次一维变换
3. **零填充**：避免循环卷积的环绕效应
4. **逆变换**：恢复时域系数

这种方法的优势在于将 $O(n^4)$ 的朴素算法降低到 $O(n^2 \log n)$，对于大规模二元多项式计算至关重要。

## Q: 这里行列的操作顺序是不重要的吧

**是的，行列的操作顺序确实不重要。** 无论是先对行变换再对列变换，还是先对列变换再对行变换，最终得到的二维傅里叶变换结果是完全相同的。

这是一个由**变换核的可分离性**直接保证的数学性质。

### 核心原理

一个二维离散傅里叶变换的定义为：
$$
F(u, v) = \sum_{x=0}^{M-1} \sum_{y=0}^{N-1} f(x, y) \cdot e^{-2\pi i (ux/M + vy/N)}
$$

关键在于，指数项可以拆分为两个独立部分的乘积：
$$
e^{-2\pi i (ux/M + vy/N)} = e^{-2\pi i (ux/M)} \cdot e^{-2\pi i (vy/N)}
$$

因此，求和也可以分离为两个步骤：

1.  **先行后列**：先对每一行（固定 x）做关于 y 的一维 FFT，然后再对每一列（固定 y）做关于 x 的一维 FFT。
2.  **先列后行**：先对每一列（固定 y）做关于 x 的一维 FFT，然后再对每一行（固定 x）做关于 y 的一维 FFT。

这两种顺序只是在执行一维变换时选取的“路径”不同，最终都等价于对二维平面上的所有点按照上述定义式求和。**数学上，它们是严格可交换的**。

### 对算法实现的影响

在你的 C++ 实现中：

```cpp
// 方法A：先行后列（你采用的方案）
1. for each row: ntt(row)    // 变换y维度
2. transpose matrix
3. for each row of transposed (即原矩阵的列): ntt(row) // 变换x维度
4. transpose back

// 方法B：先列后行（等价方案）
1. transpose matrix
2. for each row of transposed (即原矩阵的列): ntt(row) // 变换x维度
3. transpose back
4. for each row: ntt(row)    // 变换y维度
```

两种方法在数学上是等价的。你选择“先行后列”的顺序，通过一次转置来实现列变换，这在实现上很常见。

### 重要的唯一性前提

虽然顺序不重要，但要保证结果唯一和正确，**以下三点在所有步骤中必须保持一致**：

1.  **单位根的一致性**：无论是行变换还是列变换，都必须基于同一个质数模数 `MOD` 和同一个原根 `ROOT` 来计算单位根。例如，长度为 `len` 的变换，使用的单位根必须是 `g^((MOD-1)/len)`，与它是行还是列无关。
2.  **逆变换的配对性**：在做逆变换 (Inverse NTT) 时，顺序必须和正变换完全相反。如果正变换是“先行后列”，那么逆变换必须是“先列后行”。
3.  **填充长度**：行变换和列变换所需的扩展长度（2的幂次）可能不同，需要分别计算并正确应用。

### 总结

所以，你的直觉是正确的。在实现二维 FFT/NTT 时，**先处理哪个维度是任意的**。这是一个实现上的自由度，不影响算法的数学正确性。你代码中先做行变换、转置、再做行变换（相当于对原矩阵的列变换）的策略，是分离式二维 FFT 的一种标准且正确的实现方式。