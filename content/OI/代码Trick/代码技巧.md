---
tags:
  - 代码
---

>[!快速前后继]
>`prev(it)` 可以直接给出一个迭代器的前继，而不用 `auto it=...;it--;` 然后再用 it ，十分方便。甚至可以 `prev(it,3)` 来一次跳 3 个。
`next(it)` 是一样的。


>[!删除 multiset 中的单个元素]
>```cpp
>set.erase(set.find(val)); // 用迭代器删就能只删 1 个
>```


>[!快速 clear 一个 unordered_set 的元素]
>```cpp
>// s 是一个有元素的 unordered_set
>unordered_set emptyset{};
>swap(emptyset,s);
>```
>至于为什么更快，[[unordered_set 的清空|Deepseek的解答]]


>[!重载 new 来提高 vector 速度]
>```cpp
>char pool[20*N];
int top=0;
void* operator new(size_t siz) {
int src=top;top+=siz;
return pool+src;
}
void operator delete(void* p) noexcept {}
void operator delete(void* p,size_t siz) noexcept {}
>```
>注意同时重载两个版本的delete，而且不要free
>注意网上信息的过时性



