---
tags:
  - 打包背包
---
 
 [模拟赛 - 采矿](https://www.mxoj.net/problem/P130093?trainingNumber=T1827)

思路：这里的矿物能感觉出来，如果剩余的空间能塞满一个大的物品，那也一定能用小的物品塞满，那么大的物品填完后就还有一点剩余是只能用小的填满的，就好像小的物品是打包好一组一组出现的
于是反过来，令矿物质量去重后从小到大是 $a_1,a_2,\cdots,a_k$ ，那么先用 $v=a_1$ 的物品填充 $m\ \text{mod}\ a_2$ 的空间，接着把 $v=a_1$ 的物品质量每 $a_2$ 就打一个包，当成 $a_2$ 的物品，继续重复即可
这里原题解给出的一种想法是把所有的质量都除以 $a_2$ 归一化成 1 算，但并不会方便一点

```cpp
const int N=5e5+5;
int n,m;
pii v[N];
vector<int> val[N];
int a[N];
signed main() {
	File(test);
	cin>>n>>m;
    For(i,1,n)cin>>v[i].r>>v[i].l;
    sort(v+1,v+n+1);
    int lst=0,nn=0;
    For(i,1,n){
        if (v[i].l!=lst) lst=v[i].l,a[++nn]=lst;
        val[nn].pb(v[i].r);
    }
    a[nn+1]=1e18;
    int ans=0;
    For(i,1,nn){
        sort(rg(val[i]),greater<int>());
        int r=min((ll)val[i].size(),(m%a[i+1])/a[i]);
        For(k,0,r-1) ans+=val[i][k];
        m-=r*a[i];
        for(int k=r;k<val[i].size();k+=a[i+1]/a[i]){
            int s=0;
            for(int j=k;j<k+a[i+1]/a[i]&&j<val[i].size();j++) s+=val[i][j];
            val[i+1].pb(s);
        }
    }
    cout<<ans<<endl;
	return 0;
}
```

作为对比，这是当年 AC 的代码，按照题解做了归一化
```cpp
const int N=5e5+5,M=50;
pair<int,int> f[N];
int n,v[M][N],nv[M],m,dv[N];
signed main(){
    freopen("mining.in","r",stdin);
    freopen("mining.out","w",stdout);
    cin>>n>>m;
    For(i,1,n)cin>>f[i].r>>f[i].l;
    sort(f+1,f+n+1);
    int lv=0,vi=0;
    For(i,1,n){
        if(lv!=f[i].l)lv=f[i].l,vi++,dv[vi]=f[i].l;
        v[vi][++nv[vi]]=f[i].r;
    }
    int ans=0;
    dv[vi+1]=dv[vi];
    For(i,1,vi){
        sort(v[i]+1,v[i]+1+nv[i],greater<int>());
        int mp=m/dv[i],fp=mp%(dv[i+1]/dv[i]);
        if(i==vi)fp=mp;
        For(j,1,min(fp,nv[i])){
            ans+=v[i][j];
        }
        int s=dv[i+1]/dv[i];
        For(j,fp+1,nv[i]){
            nv[i+1]++;
            For(k,1,s){
                v[i+1][nv[i+1]]+=v[i][j];
                j++;
            }
            j--;
        }
    }
    cout<<ans<<endl;
    return 0;
}
```
实际上还更长