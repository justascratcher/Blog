---
tags:
  - 数据结构/可持久化线段树（主席树）
  - 数据结构/堆
  - 堆维护多点答案统计
  - 分裂搜索
  - need_another_impl
  - RMQ
---
[P2048 超级钢琴 - 洛谷](https://www.luogu.com.cn/problem/P2048)

思路：把以每一个点开始的和弦的答案用一个大根堆统计，每次取出根后，把对应点的次大答案再加入堆
这样只要考虑如何维护单个点开始的和弦的答案的后继答案即可
那么其实就是要处理前缀和在一个区间的次大的答案，

到这里，我最初的想法：
那只要把先前查出的答案对应点全部都赋成 -inf 即可。但这样是会相互干扰的，那么可以用主席树维护即可

但是更好的思路是把区间去掉最优点后把左右剩余的两个区间再次加入堆即可，这样子显然是对的

加区间做法：
```cpp
int n,k,l,r;
int st[N][LOGN];
int sti[N][LOGN];
int a[N],lg2[N];
pii qry(int l,int r){
    int k=lg2[r-l+1];
    return st[l][k]>st[r-(1<<k)+1][k]?pii{st[l][k],sti[l][k]}:pii{st[r-(1<<k)+1][k],sti[r-(1<<k)+1][k]};
}
pii qry(int i,int l,int r) {
    pii ret = qry(l,r);
    ret.l -= st[i-1][0];
    return ret;
}
struct S {int p,l,r;bool operator<(const S& s)const{return p<s.p;}};
signed main() {
	File(test);
	cin>>n>>k>>l>>r;
    For(i,1,n)cin>>a[i];
    lg2[0]=-1;
    For(i,1,n)lg2[i]=lg2[i>>1]+1;
    For(i,1,n)st[i][0]=st[i-1][0]+a[i],sti[i][0]=i;
    For(j,1,LOGN-1){
        For(i,1,n-(1<<j)+1) {
            st[i][j]=max(st[i][j-1],st[i+(1<<(j-1))][j-1]);
            if (st[i][j]==st[i][j-1])sti[i][j]=sti[i][j-1];
            else sti[i][j]=sti[i+(1<<(j-1))][j-1];
        }
    }
    l--,r--;
    priority_queue<pair<pii,S>> q;
    For(i,1,n-l)q.push({qry(i,i+l,min(i+r,n)),{i,i+l,min(n,i+r)}});
    int ans=0;
    while(k--){
        auto c=q.top();q.pop();
        ans+=c.l.l;
        int cl=c.r.l,cr=c.r.r,cp=c.l.r,ci=c.r.p;
        if (cl<cp)q.push({qry(ci,cl,cp-1),{ci,cl,cp-1}});
        if (cp<cr)q.push({qry(ci,cp+1,cr),{ci,cp+1,cr}});
    }
    cout<<ans<<endl;
    return 0;
}
```

主席树做法：
```cpp

```